* ideas o conceptos
** tdbc para un desarrollo conjunto a partir de ahora
ir programando sqlite3 con tbdc cosa que sirva el mismo proc y el
mismo metodo para ambos mundos como ya lo tengo con llenax resulset.
** uso abreviado del resulset
#+BEGIN_SRC 
set recordset [[db prepare "select * from clientes"] execute ]
#+END_SRC
** nuevo look
el look basico sin el optiondatabase. Que para la notebook es tiny,
para mi compu es un poco mas grande y para la del fede sera mas grande
pq se arregla agrandando el tipo de letra.
Es un look claro y limpio como el theme que tengo en emacs ahora
(leuven), fondo blanco, azul, bisque, amarillo, lightyellow,
celeste. En los tbls uso el pink/lightblue/lightgreen. Y de ultima
jugaria con un optiondatabse diferencial para el Fede luego.
No deja de ser extenuante de todos modos el tema color y diseño. Por
ahi el diseño y color estilo F13 es agradable luego de años del tosco
fondo #333333 y el alto contraste que presenta el tablelist con
colores chocantes a la vista. Lo que no hay que hacer es que el
colorinche penalice el tiempo de apertura como en stock, eso es
inaceptable.
** funcionamiento del prepare/stmt/resultset
se puede hacer el prepare con =: o sea no molesta el {} ya que no es
lo mismo hacer zona=:zona que zona=$zona, incluso funciona en los
casos de calle=:calle cuando calle es {Obispo Castellano} o sea nos
olvidamos de entrecomillar nosotros. 
Luego que el prepare esta listo cuando se dispara el execute, se busca
el valor que tiene la variable en el ambito que llamo el execute y si
no existe la variable se pone null, salvo que luego del execute
agreguemos un dict {calle Solares} O sea de una inteligencia total.
** clipboard
aparte de la sencillez de clipboard clear, clipboard append, ahora
tengo clipboard get facil para bindear a <3>
bind .dni <3> {set dni [clipboard get]}
y nada mas no hace falta limpiar ni nada, 
** $resultset nextdict vardict
directamente te tira un row como diccionario en forma muy directa
luego para sacar la variable chequeamos con dict exists y luego dict
get pq sino da error.

#+BEGIN_SRC
foreach w {nombre calle num barrio wapp tel} {
    if {[dict exists $cliente $w]} {
    set $w [dict get $cliente $w]
}}
#+END_SRC

tener en cuenta tambien que se puede transformar ese dict en un array
muy facilmente 
p.e.
$resulset nextdict dictcliente
array set cliente $dictcliente ;# donde se paso el dict al array
luego $cliente(nombre) $cliente(calle) etc seran operativos por lo
cual estariamos en la misma operatividad que teniamos con el viejo
sqlite solo con una linea de codigo. o sea array set.
Esto es repractico pq no tenemos que andar con un monton de variables
y solo globalizamos el nombre del array, y el manejo automatico de los
nombres de las columnas de la tabla lo hace el dict/array.
** el resaltado en proc aparte
como ya lo vengo haciendo es mas claro de mantener y de ubicar, muchas
veces tienen el mismo patron, y practicamente se agrupan los proc con
el mismo prefijo o sea empiezan con res y ya sabemos que es un resaltado.

* proyectos
** DONE catalogo/catalogopg
- State "DONE"       from "TODO"       [2019-04-04 jue 20:16]
este lo tuve que dividir porque hay una situacion de datos que hace
imposible mantenerlos juntos. Pero los voy llevando unidos desde ahora
o no los hare mas.
Tiene un tbls de tablas, (en caso de sqlite filtra las views
indeseables), y luego automaticamente muestra las columnas y el
contenido de las ultimas 100 filas, y con doble click en el bodytag
del tablelist obtengo la totalidad de los registros.
** TODO autorizador
seria un megaform que tome el DNI que pueda pegarse con boton derecho
y/o un boton, que busque en romitex y entregue toda la info en forma
clara y concisa en formatos de colores y tablas bien visibles.

Como segunda parte que tenga un registro de las autorizaciones pedidas
con fecha y hora y su resultado, pq abajo se pondria si fue autorizado
o rechazado. 


