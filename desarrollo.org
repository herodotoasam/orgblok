* ideas o conceptos
** tdbc para un desarrollo conjunto a partir de ahora
ir programando sqlite3 con tbdc cosa que sirva el mismo proc y el
mismo metodo para ambos mundos como ya lo tengo con llenax resulset.
** uso abreviado del resulset
#+BEGIN_SRC 
set recordset [[db prepare "select * from clientes"] execute ]
#+END_SRC
** nuevo look
el look basico sin el optiondatabase. Que para la notebook es tiny,
para mi compu es un poco mas grande y para la del fede sera mas grande
pq se arregla agrandando el tipo de letra.
Es un look claro y limpio como el theme que tengo en emacs ahora
(leuven), fondo blanco, azul, bisque, amarillo, lightyellow,
celeste. En los tbls uso el pink/lightblue/lightgreen. Y de ultima
jugaria con un optiondatabse diferencial para el Fede luego.
No deja de ser extenuante de todos modos el tema color y diseño. Por
ahi el diseño y color estilo F13 es agradable luego de años del tosco
fondo #333333 y el alto contraste que presenta el tablelist con
colores chocantes a la vista. Lo que no hay que hacer es que el
colorinche penalice el tiempo de apertura como en stock, eso es
inaceptable.
** funcionamiento del prepare/stmt/resultset
se puede hacer el prepare con =: o sea no molesta el {} ya que no es
lo mismo hacer zona=:zona que zona=$zona, incluso funciona en los
casos de calle=:calle cuando calle es {Obispo Castellano} o sea nos
olvidamos de entrecomillar nosotros. 
Luego que el prepare esta listo cuando se dispara el execute, se busca
el valor que tiene la variable en el ambito que llamo el execute y si
no existe la variable se pone null, salvo que luego del execute
agreguemos un dict {calle Solares} O sea de una inteligencia total.
** clipboard
aparte de la sencillez de clipboard clear, clipboard append, ahora
tengo clipboard get facil para bindear a <3>
bind .dni <3> {set dni [clipboard get]}
y nada mas no hace falta limpiar ni nada, 
** $resultset nextdict vardict
directamente te tira un row como diccionario en forma muy directa
luego para sacar la variable chequeamos con dict exists y luego dict
get pq sino da error.

#+BEGIN_SRC
foreach w {nombre calle num barrio wapp tel} {
    if {[dict exists $cliente $w]} {
    set $w [dict get $cliente $w]
}}
#+END_SRC

tener en cuenta tambien que se puede transformar ese dict en un array
muy facilmente 
p.e.
$resulset nextdict dictcliente
array set cliente $dictcliente ;# donde se paso el dict al array
luego $cliente(nombre) $cliente(calle) etc seran operativos por lo
cual estariamos en la misma operatividad que teniamos con el viejo
sqlite solo con una linea de codigo. o sea array set.
Esto es repractico pq no tenemos que andar con un monton de variables
y solo globalizamos el nombre del array, y el manejo automatico de los
nombres de las columnas de la tabla lo hace el dict/array.
** el resaltado en proc aparte
como ya lo vengo haciendo es mas claro de mantener y de ubicar, muchas
veces tienen el mismo patron, y practicamente se agrupan los proc con
el mismo prefijo o sea empiezan con res y ya sabemos que es un resaltado.
** cambios en llenarx / recalcx
para evitar problemas e integrar recalcx hice los siguientes cambios:
1. el metodo recalc le puse un if inicial que se fija si la variable
   _tdbc es 1 y pasa por alto todo y directamente llama a
   recalcx. recalcx lo que hace es llenarx $_stmt $_res siendo estas
   ambas variables guardadas oportunamente
2. lamentablemente no puedo trabajar con resulset sino un paso mas
   atras con stmt y hacer que el resultset lo calcule el llenarx. O
   sea hago el prepare directo
   set stmt [db prepare sql]  y eso envio al llenarx.
3. La unica desventaja (y lo que me hizo perder mucho tiempo) es que
   pierdo el :var y la lectura local del ambito llamante, lo cual es
   obvio usandose asi como metodo y menos guardandose en la clase para
   un recalculo. Asi que el stmt se debe hacer entrecomillado y
   calculado con las variables del momento con $, cuidando los ''
   respectivos y enviar el stmt que responda a lo local, sino ese
   prepare no obtendra ningun resultado en la clase.
** tema current_timestamp/datetime
en sqlite el current_timestam se guarda en en UTC o sea en GMT lo cual
difiere 3 hs lo nuestro. Lo cual es considerado una buena practica a
nivel base de datos.
Para expresarlo en los formularios hay que hacer la transcripcion a
localtime, mediante la funcion datetime(campofecha,'localtime'), con
el modificador 'localtime' se logra que se muestre la hora correcta.
* proyectos
** DONE catalogo/catalogopg
- State "DONE"       from "TODO"       [2019-04-04 jue 20:16]
este lo tuve que dividir porque hay una situacion de datos que hace
imposible mantenerlos juntos. Pero los voy llevando unidos desde ahora
o no los hare mas.
Tiene un tbls de tablas, (en caso de sqlite filtra las views
indeseables), y luego automaticamente muestra las columnas y el
contenido de las ultimas 100 filas, y con doble click en el bodytag
del tablelist obtengo la totalidad de los registros.
** TODO autorizador
seria un megaform que tome el DNI que pueda pegarse con boton derecho
y/o un boton, que busque en romitex y entregue toda la info en forma
clara y concisa en formatos de colores y tablas bien visibles.

Como segunda parte que tenga un registro de las autorizaciones pedidas
con fecha y hora y su resultado, pq abajo se pondria si fue autorizado
o rechazado. 


Por el momento estoy en la simpleza de mostrar una tabla con los datos
en un tbls y ver la direccion.
Me movere ahora en la de autorizar/rechazar y ver las "direcciones" en
las cuales van vendiendo para ver que no haya problema ahi lo cual
puede ser dificultoso cuando vayan avanzando.

Pero queda el problema de las direcciones de los que no sean clientes
para ver si hay ventas en la direccion. alli habra otro cuadrito de
entrada con calle y numero.

Tendriamos que ir un paso mas alla ahora y buscar que la direccion no
aparezca ni en la aclaracion ni en ningun otro campo, para evitar el
efecto usuahia 1872.

Agregue link a comentarios viejos y nuevos.
Por el momento no veo nada para agregar.
* Ideas en general
** ir depurando comentarios a mano
va a ser la unica manera de salir de eso
** agregar campos de info no visible en ficha pero util para informacion
como un campo direccion relacionada, un campo persona relacionada, o
acaso ese concepto se une al anterior, un campo que se pueda anotar en
el momento de la venta pq sigo anotando o bien en infoseven o en
comentarios viejos, un campo para que quede la info en primera plana
para la aprobacion o denegacion de creditos futuros que tenga
prioridad sobre todos los otros items o sea que sea como el campo
nuevo. y lo que diga ese campo nuevo no se discute.
